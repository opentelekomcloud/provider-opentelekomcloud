// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"
)

type AccessConfigInitParameters struct {

	// Specifies the collection path blacklist.
	// +listType=set
	BlackPaths []*string `json:"blackPaths,omitempty" tf:"black_paths,omitempty"`

	// Specifies the regular expression matching of kubernetes container names.
	// LTS will collect logs of the containers with names matching this expression. To collect logs of all containers,
	// leave this field empty.
	ContainerNameRegex *string `json:"containerNameRegex,omitempty" tf:"container_name_regex,omitempty"`

	// Specifies the environment variable blacklist. A maximum of 30 tags can be
	// created. The key names must be unique. LTS will exclude all containers with environment variables containing either
	// an environment variable key with an empty corresponding environment variable value, or an environment variable key
	// with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
	// expression matching.
	// +mapType=granular
	ExcludeEnvs map[string]*string `json:"excludeEnvs,omitempty" tf:"exclude_envs,omitempty"`

	// Specifies the kubernetes label blacklist. A maximum of 30 tags can be
	// created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
	// excluded. If labelValue is not empty, only containers whose K8s label contains LabelKey=LabelValue are excluded.
	// LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists are in the
	// OR relationship. That is, a K8s Label can be excluded as long as it meets any of the blacklists.
	// +mapType=granular
	ExcludeK8SLabels map[string]*string `json:"excludeK8SLabels,omitempty" tf:"exclude_k8s_labels,omitempty"`

	// Specifies the container label blacklist. A maximum of 30 tags can be created.
	// The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
	// excluded. If labelValue is not empty, only containers whose container label contains LabelKey=LabelValue are
	// excluded. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists
	// are in the OR relationship. That is, a container label can be excluded as long as it meets any of the blacklists.
	// +mapType=granular
	ExcludeLabels map[string]*string `json:"excludeLabels,omitempty" tf:"exclude_labels,omitempty"`

	// Specifies the environment variable whitelist. A maximum of 30 tags can be
	// created. The key names must be unique. LTS will match all containers with environment variables containing either
	// an environment variable key with an empty corresponding environment variable value, or an environment variable key
	// with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
	// expression matching.
	// +mapType=granular
	IncludeEnvs map[string]*string `json:"includeEnvs,omitempty" tf:"include_envs,omitempty"`

	// Specifies the kubernetes label whitelist. A maximum of 30 tags can be
	// created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
	// matched. If labelValue is not empty, only containers whose K8s Label contains LabelKey=LabelValue are matched.
	// LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists are in the
	// OR relationship. That is, a K8s label can be matched as long as it meets any of the whitelists.
	// +mapType=granular
	IncludeK8SLabels map[string]*string `json:"includeK8SLabels,omitempty" tf:"include_k8s_labels,omitempty"`

	// Specifies the container label whitelist. A maximum of 30 tags can be created.
	// The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
	// matched. If labelValue is not empty, only containers whose container label contains LabelKey=LabelValue are
	// matched. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists
	// are in the OR relationship. That is, a container label can be matched as long as it meets any of the whitelists.
	// +mapType=granular
	IncludeLabels map[string]*string `json:"includeLabels,omitempty" tf:"include_labels,omitempty"`

	// Specifies the environment variable tag. A maximum of 30 tags can be created.
	// The key names must be unique. LTS adds the specified fields to the log when each environment variable key has a
	// corresponding environment variable value. For example, if you enter app as the key and app_alias as the value,
	// when the kubernetes environment variable contains app=lts, {app_alias: lts} will be added to the log.
	// +mapType=granular
	LogEnvs map[string]*string `json:"logEnvs,omitempty" tf:"log_envs,omitempty"`

	// Specifies the kubernetes label log tag. A maximum of 30 tags can be created.
	// The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding label
	// value. For example, if you enter app as the key and app_alias as the value, when the K8s label contains
	// app=lts, {app_alias: lts} will be added to the log.
	// +mapType=granular
	LogK8S map[string]*string `json:"logK8S,omitempty" tf:"log_k8s,omitempty"`

	// Specifies the container label log tag. A maximum of 30 tags can be created.
	// The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding
	// label value. For example, if you enter app as the key and app_alias as the value, when the Container label
	// contains app=lts, {app_alias: lts} will be added to the log.
	// +mapType=granular
	LogLabels map[string]*string `json:"logLabels,omitempty" tf:"log_labels,omitempty"`

	// Specifies the configuration multi-line logs. Multiple lines of exception log
	// events can be displayed as a single log event. This is helpful when you check logs to locate problems.
	// The multi_log_format structure is documented below.
	MultiLogFormat []MultiLogFormatInitParameters `json:"multiLogFormat,omitempty" tf:"multi_log_format,omitempty"`

	// Specifies the regular expression matching of kubernetes namespaces.
	// LTS will collect logs of the namespaces with names matching this expression. To collect logs of all namespaces,
	// leave this field empty.
	NameSpaceRegex *string `json:"nameSpaceRegex,omitempty" tf:"name_space_regex,omitempty"`

	// Specifies the type of the CCE access. The options are as follows:
	PathType *string `json:"pathType,omitempty" tf:"path_type,omitempty"`

	// Specifies the collection paths. Required when path_type is container_file, container_stdout
	// or host_file.
	// +listType=set
	Paths []*string `json:"paths,omitempty" tf:"paths,omitempty"`

	// Specifies the regular expression matching of kubernetes pods.
	// LTS will collect logs of the Pods with names matching this expression. To collect logs of all Pods,
	// leave this field empty.
	PodNameRegex *string `json:"podNameRegex,omitempty" tf:"pod_name_regex,omitempty"`

	// Specifies the configuration single-line logs. Each log line is displayed
	// as a single log event.
	// The single_log_format structure is documented below.
	SingleLogFormat []SingleLogFormatInitParameters `json:"singleLogFormat,omitempty" tf:"single_log_format,omitempty"`

	// Specifies whether error output is standard. Default is false.
	Stderr *bool `json:"stderr,omitempty" tf:"stderr,omitempty"`

	// Specifies whether output is standard. Default is false.
	Stdout *bool `json:"stdout,omitempty" tf:"stdout,omitempty"`
}

type AccessConfigObservation struct {

	// Specifies the collection path blacklist.
	// +listType=set
	BlackPaths []*string `json:"blackPaths,omitempty" tf:"black_paths,omitempty"`

	// Specifies the regular expression matching of kubernetes container names.
	// LTS will collect logs of the containers with names matching this expression. To collect logs of all containers,
	// leave this field empty.
	ContainerNameRegex *string `json:"containerNameRegex,omitempty" tf:"container_name_regex,omitempty"`

	// Specifies the environment variable blacklist. A maximum of 30 tags can be
	// created. The key names must be unique. LTS will exclude all containers with environment variables containing either
	// an environment variable key with an empty corresponding environment variable value, or an environment variable key
	// with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
	// expression matching.
	// +mapType=granular
	ExcludeEnvs map[string]*string `json:"excludeEnvs,omitempty" tf:"exclude_envs,omitempty"`

	// Specifies the kubernetes label blacklist. A maximum of 30 tags can be
	// created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
	// excluded. If labelValue is not empty, only containers whose K8s label contains LabelKey=LabelValue are excluded.
	// LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists are in the
	// OR relationship. That is, a K8s Label can be excluded as long as it meets any of the blacklists.
	// +mapType=granular
	ExcludeK8SLabels map[string]*string `json:"excludeK8SLabels,omitempty" tf:"exclude_k8s_labels,omitempty"`

	// Specifies the container label blacklist. A maximum of 30 tags can be created.
	// The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
	// excluded. If labelValue is not empty, only containers whose container label contains LabelKey=LabelValue are
	// excluded. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists
	// are in the OR relationship. That is, a container label can be excluded as long as it meets any of the blacklists.
	// +mapType=granular
	ExcludeLabels map[string]*string `json:"excludeLabels,omitempty" tf:"exclude_labels,omitempty"`

	// Specifies the environment variable whitelist. A maximum of 30 tags can be
	// created. The key names must be unique. LTS will match all containers with environment variables containing either
	// an environment variable key with an empty corresponding environment variable value, or an environment variable key
	// with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
	// expression matching.
	// +mapType=granular
	IncludeEnvs map[string]*string `json:"includeEnvs,omitempty" tf:"include_envs,omitempty"`

	// Specifies the kubernetes label whitelist. A maximum of 30 tags can be
	// created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
	// matched. If labelValue is not empty, only containers whose K8s Label contains LabelKey=LabelValue are matched.
	// LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists are in the
	// OR relationship. That is, a K8s label can be matched as long as it meets any of the whitelists.
	// +mapType=granular
	IncludeK8SLabels map[string]*string `json:"includeK8SLabels,omitempty" tf:"include_k8s_labels,omitempty"`

	// Specifies the container label whitelist. A maximum of 30 tags can be created.
	// The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
	// matched. If labelValue is not empty, only containers whose container label contains LabelKey=LabelValue are
	// matched. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists
	// are in the OR relationship. That is, a container label can be matched as long as it meets any of the whitelists.
	// +mapType=granular
	IncludeLabels map[string]*string `json:"includeLabels,omitempty" tf:"include_labels,omitempty"`

	// Specifies the environment variable tag. A maximum of 30 tags can be created.
	// The key names must be unique. LTS adds the specified fields to the log when each environment variable key has a
	// corresponding environment variable value. For example, if you enter app as the key and app_alias as the value,
	// when the kubernetes environment variable contains app=lts, {app_alias: lts} will be added to the log.
	// +mapType=granular
	LogEnvs map[string]*string `json:"logEnvs,omitempty" tf:"log_envs,omitempty"`

	// Specifies the kubernetes label log tag. A maximum of 30 tags can be created.
	// The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding label
	// value. For example, if you enter app as the key and app_alias as the value, when the K8s label contains
	// app=lts, {app_alias: lts} will be added to the log.
	// +mapType=granular
	LogK8S map[string]*string `json:"logK8S,omitempty" tf:"log_k8s,omitempty"`

	// Specifies the container label log tag. A maximum of 30 tags can be created.
	// The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding
	// label value. For example, if you enter app as the key and app_alias as the value, when the Container label
	// contains app=lts, {app_alias: lts} will be added to the log.
	// +mapType=granular
	LogLabels map[string]*string `json:"logLabels,omitempty" tf:"log_labels,omitempty"`

	// Specifies the configuration multi-line logs. Multiple lines of exception log
	// events can be displayed as a single log event. This is helpful when you check logs to locate problems.
	// The multi_log_format structure is documented below.
	MultiLogFormat []MultiLogFormatObservation `json:"multiLogFormat,omitempty" tf:"multi_log_format,omitempty"`

	// Specifies the regular expression matching of kubernetes namespaces.
	// LTS will collect logs of the namespaces with names matching this expression. To collect logs of all namespaces,
	// leave this field empty.
	NameSpaceRegex *string `json:"nameSpaceRegex,omitempty" tf:"name_space_regex,omitempty"`

	// Specifies the type of the CCE access. The options are as follows:
	PathType *string `json:"pathType,omitempty" tf:"path_type,omitempty"`

	// Specifies the collection paths. Required when path_type is container_file, container_stdout
	// or host_file.
	// +listType=set
	Paths []*string `json:"paths,omitempty" tf:"paths,omitempty"`

	// Specifies the regular expression matching of kubernetes pods.
	// LTS will collect logs of the Pods with names matching this expression. To collect logs of all Pods,
	// leave this field empty.
	PodNameRegex *string `json:"podNameRegex,omitempty" tf:"pod_name_regex,omitempty"`

	// Specifies the configuration single-line logs. Each log line is displayed
	// as a single log event.
	// The single_log_format structure is documented below.
	SingleLogFormat []SingleLogFormatObservation `json:"singleLogFormat,omitempty" tf:"single_log_format,omitempty"`

	// Specifies whether error output is standard. Default is false.
	Stderr *bool `json:"stderr,omitempty" tf:"stderr,omitempty"`

	// Specifies whether output is standard. Default is false.
	Stdout *bool `json:"stdout,omitempty" tf:"stdout,omitempty"`
}

type AccessConfigParameters struct {

	// Specifies the collection path blacklist.
	// +kubebuilder:validation:Optional
	// +listType=set
	BlackPaths []*string `json:"blackPaths,omitempty" tf:"black_paths,omitempty"`

	// Specifies the regular expression matching of kubernetes container names.
	// LTS will collect logs of the containers with names matching this expression. To collect logs of all containers,
	// leave this field empty.
	// +kubebuilder:validation:Optional
	ContainerNameRegex *string `json:"containerNameRegex,omitempty" tf:"container_name_regex,omitempty"`

	// Specifies the environment variable blacklist. A maximum of 30 tags can be
	// created. The key names must be unique. LTS will exclude all containers with environment variables containing either
	// an environment variable key with an empty corresponding environment variable value, or an environment variable key
	// with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
	// expression matching.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	ExcludeEnvs map[string]*string `json:"excludeEnvs,omitempty" tf:"exclude_envs,omitempty"`

	// Specifies the kubernetes label blacklist. A maximum of 30 tags can be
	// created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
	// excluded. If labelValue is not empty, only containers whose K8s label contains LabelKey=LabelValue are excluded.
	// LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists are in the
	// OR relationship. That is, a K8s Label can be excluded as long as it meets any of the blacklists.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	ExcludeK8SLabels map[string]*string `json:"excludeK8SLabels,omitempty" tf:"exclude_k8s_labels,omitempty"`

	// Specifies the container label blacklist. A maximum of 30 tags can be created.
	// The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
	// excluded. If labelValue is not empty, only containers whose container label contains LabelKey=LabelValue are
	// excluded. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists
	// are in the OR relationship. That is, a container label can be excluded as long as it meets any of the blacklists.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	ExcludeLabels map[string]*string `json:"excludeLabels,omitempty" tf:"exclude_labels,omitempty"`

	// Specifies the environment variable whitelist. A maximum of 30 tags can be
	// created. The key names must be unique. LTS will match all containers with environment variables containing either
	// an environment variable key with an empty corresponding environment variable value, or an environment variable key
	// with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
	// expression matching.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	IncludeEnvs map[string]*string `json:"includeEnvs,omitempty" tf:"include_envs,omitempty"`

	// Specifies the kubernetes label whitelist. A maximum of 30 tags can be
	// created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
	// matched. If labelValue is not empty, only containers whose K8s Label contains LabelKey=LabelValue are matched.
	// LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists are in the
	// OR relationship. That is, a K8s label can be matched as long as it meets any of the whitelists.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	IncludeK8SLabels map[string]*string `json:"includeK8SLabels,omitempty" tf:"include_k8s_labels,omitempty"`

	// Specifies the container label whitelist. A maximum of 30 tags can be created.
	// The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
	// matched. If labelValue is not empty, only containers whose container label contains LabelKey=LabelValue are
	// matched. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists
	// are in the OR relationship. That is, a container label can be matched as long as it meets any of the whitelists.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	IncludeLabels map[string]*string `json:"includeLabels,omitempty" tf:"include_labels,omitempty"`

	// Specifies the environment variable tag. A maximum of 30 tags can be created.
	// The key names must be unique. LTS adds the specified fields to the log when each environment variable key has a
	// corresponding environment variable value. For example, if you enter app as the key and app_alias as the value,
	// when the kubernetes environment variable contains app=lts, {app_alias: lts} will be added to the log.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	LogEnvs map[string]*string `json:"logEnvs,omitempty" tf:"log_envs,omitempty"`

	// Specifies the kubernetes label log tag. A maximum of 30 tags can be created.
	// The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding label
	// value. For example, if you enter app as the key and app_alias as the value, when the K8s label contains
	// app=lts, {app_alias: lts} will be added to the log.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	LogK8S map[string]*string `json:"logK8S,omitempty" tf:"log_k8s,omitempty"`

	// Specifies the container label log tag. A maximum of 30 tags can be created.
	// The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding
	// label value. For example, if you enter app as the key and app_alias as the value, when the Container label
	// contains app=lts, {app_alias: lts} will be added to the log.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	LogLabels map[string]*string `json:"logLabels,omitempty" tf:"log_labels,omitempty"`

	// Specifies the configuration multi-line logs. Multiple lines of exception log
	// events can be displayed as a single log event. This is helpful when you check logs to locate problems.
	// The multi_log_format structure is documented below.
	// +kubebuilder:validation:Optional
	MultiLogFormat []MultiLogFormatParameters `json:"multiLogFormat,omitempty" tf:"multi_log_format,omitempty"`

	// Specifies the regular expression matching of kubernetes namespaces.
	// LTS will collect logs of the namespaces with names matching this expression. To collect logs of all namespaces,
	// leave this field empty.
	// +kubebuilder:validation:Optional
	NameSpaceRegex *string `json:"nameSpaceRegex,omitempty" tf:"name_space_regex,omitempty"`

	// Specifies the type of the CCE access. The options are as follows:
	// +kubebuilder:validation:Optional
	PathType *string `json:"pathType" tf:"path_type,omitempty"`

	// Specifies the collection paths. Required when path_type is container_file, container_stdout
	// or host_file.
	// +kubebuilder:validation:Optional
	// +listType=set
	Paths []*string `json:"paths,omitempty" tf:"paths,omitempty"`

	// Specifies the regular expression matching of kubernetes pods.
	// LTS will collect logs of the Pods with names matching this expression. To collect logs of all Pods,
	// leave this field empty.
	// +kubebuilder:validation:Optional
	PodNameRegex *string `json:"podNameRegex,omitempty" tf:"pod_name_regex,omitempty"`

	// Specifies the configuration single-line logs. Each log line is displayed
	// as a single log event.
	// The single_log_format structure is documented below.
	// +kubebuilder:validation:Optional
	SingleLogFormat []SingleLogFormatParameters `json:"singleLogFormat,omitempty" tf:"single_log_format,omitempty"`

	// Specifies whether error output is standard. Default is false.
	// +kubebuilder:validation:Optional
	Stderr *bool `json:"stderr,omitempty" tf:"stderr,omitempty"`

	// Specifies whether output is standard. Default is false.
	// +kubebuilder:validation:Optional
	Stdout *bool `json:"stdout,omitempty" tf:"stdout,omitempty"`
}

type CceAccessV3InitParameters struct {

	// Specifies the configurations of CCE access.
	// The access_config structure is documented below.
	AccessConfig []AccessConfigInitParameters `json:"accessConfig,omitempty" tf:"access_config,omitempty"`

	// Specifies whether collect in binary format. Default is false.
	BinaryCollect *bool `json:"binaryCollect,omitempty" tf:"binary_collect,omitempty"`

	// Specifies the CCE cluster ID. Changing this creates a new resource.
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Specifies the log access host group ID list.
	HostGroupIds []*string `json:"hostGroupIds,omitempty" tf:"host_group_ids,omitempty"`

	// Specifies the log group ID. Changing this creates a new resource.
	LogGroupID *string `json:"logGroupId,omitempty" tf:"log_group_id,omitempty"`

	// Specifies whether to split log. Default is false.
	LogSplit *bool `json:"logSplit,omitempty" tf:"log_split,omitempty"`

	// Specifies the log stream ID. Changing this creates a new resource.
	LogStreamID *string `json:"logStreamId,omitempty" tf:"log_stream_id,omitempty"`

	// Specifies the name of the CCE access. The name consists of 1 to 64
	// characters. Only letters, digits, underscores (_), and periods (.) are allowed, and the period cannot be the first
	// or last character. Changing this creates a new resource.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Specifies the key/value pairs to associate with the CCE access.
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type CceAccessV3Observation struct {

	// Specifies the configurations of CCE access.
	// The access_config structure is documented below.
	AccessConfig []AccessConfigObservation `json:"accessConfig,omitempty" tf:"access_config,omitempty"`

	// The log access type.
	AccessType *string `json:"accessType,omitempty" tf:"access_type,omitempty"`

	// Specifies whether collect in binary format. Default is false.
	BinaryCollect *bool `json:"binaryCollect,omitempty" tf:"binary_collect,omitempty"`

	// Specifies the CCE cluster ID. Changing this creates a new resource.
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// The creation time of the CCE access, in RFC3339 format.
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// Specifies the log access host group ID list.
	HostGroupIds []*string `json:"hostGroupIds,omitempty" tf:"host_group_ids,omitempty"`

	// The resource ID.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Specifies the log group ID. Changing this creates a new resource.
	LogGroupID *string `json:"logGroupId,omitempty" tf:"log_group_id,omitempty"`

	// The log group name.
	LogGroupName *string `json:"logGroupName,omitempty" tf:"log_group_name,omitempty"`

	// Specifies whether to split log. Default is false.
	LogSplit *bool `json:"logSplit,omitempty" tf:"log_split,omitempty"`

	// Specifies the log stream ID. Changing this creates a new resource.
	LogStreamID *string `json:"logStreamId,omitempty" tf:"log_stream_id,omitempty"`

	// The log stream name.
	LogStreamName *string `json:"logStreamName,omitempty" tf:"log_stream_name,omitempty"`

	// Specifies the name of the CCE access. The name consists of 1 to 64
	// characters. Only letters, digits, underscores (_), and periods (.) are allowed, and the period cannot be the first
	// or last character. Changing this creates a new resource.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Shows the region in the cce access resource created.
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Specifies the key/value pairs to associate with the CCE access.
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type CceAccessV3Parameters struct {

	// Specifies the configurations of CCE access.
	// The access_config structure is documented below.
	// +kubebuilder:validation:Optional
	AccessConfig []AccessConfigParameters `json:"accessConfig,omitempty" tf:"access_config,omitempty"`

	// Specifies whether collect in binary format. Default is false.
	// +kubebuilder:validation:Optional
	BinaryCollect *bool `json:"binaryCollect,omitempty" tf:"binary_collect,omitempty"`

	// Specifies the CCE cluster ID. Changing this creates a new resource.
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Specifies the log access host group ID list.
	// +kubebuilder:validation:Optional
	HostGroupIds []*string `json:"hostGroupIds,omitempty" tf:"host_group_ids,omitempty"`

	// Specifies the log group ID. Changing this creates a new resource.
	// +kubebuilder:validation:Optional
	LogGroupID *string `json:"logGroupId,omitempty" tf:"log_group_id,omitempty"`

	// Specifies whether to split log. Default is false.
	// +kubebuilder:validation:Optional
	LogSplit *bool `json:"logSplit,omitempty" tf:"log_split,omitempty"`

	// Specifies the log stream ID. Changing this creates a new resource.
	// +kubebuilder:validation:Optional
	LogStreamID *string `json:"logStreamId,omitempty" tf:"log_stream_id,omitempty"`

	// Specifies the name of the CCE access. The name consists of 1 to 64
	// characters. Only letters, digits, underscores (_), and periods (.) are allowed, and the period cannot be the first
	// or last character. Changing this creates a new resource.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Specifies the key/value pairs to associate with the CCE access.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type MultiLogFormatInitParameters struct {

	// Specifies mode of single-line log format. The options are as follows:
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// Specifies value of single-line log format.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MultiLogFormatObservation struct {

	// Specifies mode of single-line log format. The options are as follows:
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// Specifies value of single-line log format.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MultiLogFormatParameters struct {

	// Specifies mode of single-line log format. The options are as follows:
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// Specifies value of single-line log format.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SingleLogFormatInitParameters struct {

	// Specifies mode of single-line log format. The options are as follows:
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// Specifies value of single-line log format.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SingleLogFormatObservation struct {

	// Specifies mode of single-line log format. The options are as follows:
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// Specifies value of single-line log format.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SingleLogFormatParameters struct {

	// Specifies mode of single-line log format. The options are as follows:
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// Specifies value of single-line log format.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

// CceAccessV3Spec defines the desired state of CceAccessV3
type CceAccessV3Spec struct {
	v2.ManagedResourceSpec `json:",inline"`
	ForProvider            CceAccessV3Parameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider CceAccessV3InitParameters `json:"initProvider,omitempty"`
}

// CceAccessV3Status defines the observed state of CceAccessV3.
type CceAccessV3Status struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        CceAccessV3Observation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// CceAccessV3 is the Schema for the CceAccessV3s API. Manages a LTS CCE Access resource within OpenTelekomCloud.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Namespaced,categories={crossplane,managed,opentelekomcloud}
type CceAccessV3 struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.accessConfig) || (has(self.initProvider) && has(self.initProvider.accessConfig))",message="spec.forProvider.accessConfig is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.clusterId) || (has(self.initProvider) && has(self.initProvider.clusterId))",message="spec.forProvider.clusterId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.logGroupId) || (has(self.initProvider) && has(self.initProvider.logGroupId))",message="spec.forProvider.logGroupId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.logStreamId) || (has(self.initProvider) && has(self.initProvider.logStreamId))",message="spec.forProvider.logStreamId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   CceAccessV3Spec   `json:"spec"`
	Status CceAccessV3Status `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// CceAccessV3List contains a list of CceAccessV3s
type CceAccessV3List struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []CceAccessV3 `json:"items"`
}

// Repository type metadata.
var (
	CceAccessV3_Kind             = "CceAccessV3"
	CceAccessV3_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: CceAccessV3_Kind}.String()
	CceAccessV3_KindAPIVersion   = CceAccessV3_Kind + "." + CRDGroupVersion.String()
	CceAccessV3_GroupVersionKind = CRDGroupVersion.WithKind(CceAccessV3_Kind)
)

func init() {
	SchemeBuilder.Register(&CceAccessV3{}, &CceAccessV3List{})
}
