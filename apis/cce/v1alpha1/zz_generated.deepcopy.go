//go:build !ignore_autogenerated

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AddonV3) DeepCopyInto(out *AddonV3) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AddonV3.
func (in *AddonV3) DeepCopy() *AddonV3 {
	if in == nil {
		return nil
	}
	out := new(AddonV3)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AddonV3) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AddonV3InitParameters) DeepCopyInto(out *AddonV3InitParameters) {
	*out = *in
	if in.ClusterID != nil {
		in, out := &in.ClusterID, &out.ClusterID
		*out = new(string)
		**out = **in
	}
	if in.TemplateName != nil {
		in, out := &in.TemplateName, &out.TemplateName
		*out = new(string)
		**out = **in
	}
	if in.TemplateVersion != nil {
		in, out := &in.TemplateVersion, &out.TemplateVersion
		*out = new(string)
		**out = **in
	}
	if in.Values != nil {
		in, out := &in.Values, &out.Values
		*out = make([]ValuesInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AddonV3InitParameters.
func (in *AddonV3InitParameters) DeepCopy() *AddonV3InitParameters {
	if in == nil {
		return nil
	}
	out := new(AddonV3InitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AddonV3List) DeepCopyInto(out *AddonV3List) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]AddonV3, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AddonV3List.
func (in *AddonV3List) DeepCopy() *AddonV3List {
	if in == nil {
		return nil
	}
	out := new(AddonV3List)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AddonV3List) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AddonV3Observation) DeepCopyInto(out *AddonV3Observation) {
	*out = *in
	if in.ClusterID != nil {
		in, out := &in.ClusterID, &out.ClusterID
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.TemplateName != nil {
		in, out := &in.TemplateName, &out.TemplateName
		*out = new(string)
		**out = **in
	}
	if in.TemplateVersion != nil {
		in, out := &in.TemplateVersion, &out.TemplateVersion
		*out = new(string)
		**out = **in
	}
	if in.Values != nil {
		in, out := &in.Values, &out.Values
		*out = make([]ValuesObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AddonV3Observation.
func (in *AddonV3Observation) DeepCopy() *AddonV3Observation {
	if in == nil {
		return nil
	}
	out := new(AddonV3Observation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AddonV3Parameters) DeepCopyInto(out *AddonV3Parameters) {
	*out = *in
	if in.ClusterID != nil {
		in, out := &in.ClusterID, &out.ClusterID
		*out = new(string)
		**out = **in
	}
	if in.TemplateName != nil {
		in, out := &in.TemplateName, &out.TemplateName
		*out = new(string)
		**out = **in
	}
	if in.TemplateVersion != nil {
		in, out := &in.TemplateVersion, &out.TemplateVersion
		*out = new(string)
		**out = **in
	}
	if in.Values != nil {
		in, out := &in.Values, &out.Values
		*out = make([]ValuesParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AddonV3Parameters.
func (in *AddonV3Parameters) DeepCopy() *AddonV3Parameters {
	if in == nil {
		return nil
	}
	out := new(AddonV3Parameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AddonV3Spec) DeepCopyInto(out *AddonV3Spec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AddonV3Spec.
func (in *AddonV3Spec) DeepCopy() *AddonV3Spec {
	if in == nil {
		return nil
	}
	out := new(AddonV3Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AddonV3Status) DeepCopyInto(out *AddonV3Status) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AddonV3Status.
func (in *AddonV3Status) DeepCopy() *AddonV3Status {
	if in == nil {
		return nil
	}
	out := new(AddonV3Status)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthenticatingProxyInitParameters) DeepCopyInto(out *AuthenticatingProxyInitParameters) {
	*out = *in
	if in.CA != nil {
		in, out := &in.CA, &out.CA
		*out = new(string)
		**out = **in
	}
	if in.Cert != nil {
		in, out := &in.Cert, &out.Cert
		*out = new(string)
		**out = **in
	}
	if in.PrivateKey != nil {
		in, out := &in.PrivateKey, &out.PrivateKey
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthenticatingProxyInitParameters.
func (in *AuthenticatingProxyInitParameters) DeepCopy() *AuthenticatingProxyInitParameters {
	if in == nil {
		return nil
	}
	out := new(AuthenticatingProxyInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthenticatingProxyObservation) DeepCopyInto(out *AuthenticatingProxyObservation) {
	*out = *in
	if in.CA != nil {
		in, out := &in.CA, &out.CA
		*out = new(string)
		**out = **in
	}
	if in.Cert != nil {
		in, out := &in.Cert, &out.Cert
		*out = new(string)
		**out = **in
	}
	if in.PrivateKey != nil {
		in, out := &in.PrivateKey, &out.PrivateKey
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthenticatingProxyObservation.
func (in *AuthenticatingProxyObservation) DeepCopy() *AuthenticatingProxyObservation {
	if in == nil {
		return nil
	}
	out := new(AuthenticatingProxyObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthenticatingProxyParameters) DeepCopyInto(out *AuthenticatingProxyParameters) {
	*out = *in
	if in.CA != nil {
		in, out := &in.CA, &out.CA
		*out = new(string)
		**out = **in
	}
	if in.Cert != nil {
		in, out := &in.Cert, &out.Cert
		*out = new(string)
		**out = **in
	}
	if in.PrivateKey != nil {
		in, out := &in.PrivateKey, &out.PrivateKey
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthenticatingProxyParameters.
func (in *AuthenticatingProxyParameters) DeepCopy() *AuthenticatingProxyParameters {
	if in == nil {
		return nil
	}
	out := new(AuthenticatingProxyParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CertificateClustersInitParameters) DeepCopyInto(out *CertificateClustersInitParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CertificateClustersInitParameters.
func (in *CertificateClustersInitParameters) DeepCopy() *CertificateClustersInitParameters {
	if in == nil {
		return nil
	}
	out := new(CertificateClustersInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CertificateClustersObservation) DeepCopyInto(out *CertificateClustersObservation) {
	*out = *in
	if in.CertificateAuthorityData != nil {
		in, out := &in.CertificateAuthorityData, &out.CertificateAuthorityData
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Server != nil {
		in, out := &in.Server, &out.Server
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CertificateClustersObservation.
func (in *CertificateClustersObservation) DeepCopy() *CertificateClustersObservation {
	if in == nil {
		return nil
	}
	out := new(CertificateClustersObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CertificateClustersParameters) DeepCopyInto(out *CertificateClustersParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CertificateClustersParameters.
func (in *CertificateClustersParameters) DeepCopy() *CertificateClustersParameters {
	if in == nil {
		return nil
	}
	out := new(CertificateClustersParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CertificateUsersInitParameters) DeepCopyInto(out *CertificateUsersInitParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CertificateUsersInitParameters.
func (in *CertificateUsersInitParameters) DeepCopy() *CertificateUsersInitParameters {
	if in == nil {
		return nil
	}
	out := new(CertificateUsersInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CertificateUsersObservation) DeepCopyInto(out *CertificateUsersObservation) {
	*out = *in
	if in.ClientCertificateData != nil {
		in, out := &in.ClientCertificateData, &out.ClientCertificateData
		*out = new(string)
		**out = **in
	}
	if in.ClientKeyData != nil {
		in, out := &in.ClientKeyData, &out.ClientKeyData
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CertificateUsersObservation.
func (in *CertificateUsersObservation) DeepCopy() *CertificateUsersObservation {
	if in == nil {
		return nil
	}
	out := new(CertificateUsersObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CertificateUsersParameters) DeepCopyInto(out *CertificateUsersParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CertificateUsersParameters.
func (in *CertificateUsersParameters) DeepCopy() *CertificateUsersParameters {
	if in == nil {
		return nil
	}
	out := new(CertificateUsersParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterV3) DeepCopyInto(out *ClusterV3) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterV3.
func (in *ClusterV3) DeepCopy() *ClusterV3 {
	if in == nil {
		return nil
	}
	out := new(ClusterV3)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClusterV3) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterV3InitParameters) DeepCopyInto(out *ClusterV3InitParameters) {
	*out = *in
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.AuthenticatingProxy != nil {
		in, out := &in.AuthenticatingProxy, &out.AuthenticatingProxy
		*out = make([]AuthenticatingProxyInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.AuthenticatingProxyCA != nil {
		in, out := &in.AuthenticatingProxyCA, &out.AuthenticatingProxyCA
		*out = new(string)
		**out = **in
	}
	if in.AuthenticationMode != nil {
		in, out := &in.AuthenticationMode, &out.AuthenticationMode
		*out = new(string)
		**out = **in
	}
	if in.BillingMode != nil {
		in, out := &in.BillingMode, &out.BillingMode
		*out = new(float64)
		**out = **in
	}
	if in.ClusterType != nil {
		in, out := &in.ClusterType, &out.ClusterType
		*out = new(string)
		**out = **in
	}
	if in.ClusterVersion != nil {
		in, out := &in.ClusterVersion, &out.ClusterVersion
		*out = new(string)
		**out = **in
	}
	if in.ContainerNetworkCidr != nil {
		in, out := &in.ContainerNetworkCidr, &out.ContainerNetworkCidr
		*out = new(string)
		**out = **in
	}
	if in.ContainerNetworkType != nil {
		in, out := &in.ContainerNetworkType, &out.ContainerNetworkType
		*out = new(string)
		**out = **in
	}
	if in.DeleteAllNetwork != nil {
		in, out := &in.DeleteAllNetwork, &out.DeleteAllNetwork
		*out = new(string)
		**out = **in
	}
	if in.DeleteAllStorage != nil {
		in, out := &in.DeleteAllStorage, &out.DeleteAllStorage
		*out = new(string)
		**out = **in
	}
	if in.DeleteEFS != nil {
		in, out := &in.DeleteEFS, &out.DeleteEFS
		*out = new(string)
		**out = **in
	}
	if in.DeleteEni != nil {
		in, out := &in.DeleteEni, &out.DeleteEni
		*out = new(string)
		**out = **in
	}
	if in.DeleteEvs != nil {
		in, out := &in.DeleteEvs, &out.DeleteEvs
		*out = new(string)
		**out = **in
	}
	if in.DeleteNet != nil {
		in, out := &in.DeleteNet, &out.DeleteNet
		*out = new(string)
		**out = **in
	}
	if in.DeleteObs != nil {
		in, out := &in.DeleteObs, &out.DeleteObs
		*out = new(string)
		**out = **in
	}
	if in.DeleteSfs != nil {
		in, out := &in.DeleteSfs, &out.DeleteSfs
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.EIP != nil {
		in, out := &in.EIP, &out.EIP
		*out = new(string)
		**out = **in
	}
	if in.EnableVolumeEncryption != nil {
		in, out := &in.EnableVolumeEncryption, &out.EnableVolumeEncryption
		*out = new(bool)
		**out = **in
	}
	if in.EniSubnetCidr != nil {
		in, out := &in.EniSubnetCidr, &out.EniSubnetCidr
		*out = new(string)
		**out = **in
	}
	if in.EniSubnetID != nil {
		in, out := &in.EniSubnetID, &out.EniSubnetID
		*out = new(string)
		**out = **in
	}
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.FlavorID != nil {
		in, out := &in.FlavorID, &out.FlavorID
		*out = new(string)
		**out = **in
	}
	if in.HighwaySubnetID != nil {
		in, out := &in.HighwaySubnetID, &out.HighwaySubnetID
		*out = new(string)
		**out = **in
	}
	if in.IgnoreAddons != nil {
		in, out := &in.IgnoreAddons, &out.IgnoreAddons
		*out = new(bool)
		**out = **in
	}
	if in.IgnoreCertificateClustersData != nil {
		in, out := &in.IgnoreCertificateClustersData, &out.IgnoreCertificateClustersData
		*out = new(bool)
		**out = **in
	}
	if in.IgnoreCertificateUsersData != nil {
		in, out := &in.IgnoreCertificateUsersData, &out.IgnoreCertificateUsersData
		*out = new(bool)
		**out = **in
	}
	if in.KubeProxyMode != nil {
		in, out := &in.KubeProxyMode, &out.KubeProxyMode
		*out = new(string)
		**out = **in
	}
	if in.KubernetesSvcIPRange != nil {
		in, out := &in.KubernetesSvcIPRange, &out.KubernetesSvcIPRange
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MultiAz != nil {
		in, out := &in.MultiAz, &out.MultiAz
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NoAddons != nil {
		in, out := &in.NoAddons, &out.NoAddons
		*out = new(bool)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.SubnetID != nil {
		in, out := &in.SubnetID, &out.SubnetID
		*out = new(string)
		**out = **in
	}
	if in.VPCID != nil {
		in, out := &in.VPCID, &out.VPCID
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterV3InitParameters.
func (in *ClusterV3InitParameters) DeepCopy() *ClusterV3InitParameters {
	if in == nil {
		return nil
	}
	out := new(ClusterV3InitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterV3List) DeepCopyInto(out *ClusterV3List) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClusterV3, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterV3List.
func (in *ClusterV3List) DeepCopy() *ClusterV3List {
	if in == nil {
		return nil
	}
	out := new(ClusterV3List)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClusterV3List) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterV3Observation) DeepCopyInto(out *ClusterV3Observation) {
	*out = *in
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.AuthenticatingProxy != nil {
		in, out := &in.AuthenticatingProxy, &out.AuthenticatingProxy
		*out = make([]AuthenticatingProxyObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.AuthenticatingProxyCA != nil {
		in, out := &in.AuthenticatingProxyCA, &out.AuthenticatingProxyCA
		*out = new(string)
		**out = **in
	}
	if in.AuthenticationMode != nil {
		in, out := &in.AuthenticationMode, &out.AuthenticationMode
		*out = new(string)
		**out = **in
	}
	if in.BillingMode != nil {
		in, out := &in.BillingMode, &out.BillingMode
		*out = new(float64)
		**out = **in
	}
	if in.CertificateClusters != nil {
		in, out := &in.CertificateClusters, &out.CertificateClusters
		*out = make([]CertificateClustersObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CertificateUsers != nil {
		in, out := &in.CertificateUsers, &out.CertificateUsers
		*out = make([]CertificateUsersObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ClusterType != nil {
		in, out := &in.ClusterType, &out.ClusterType
		*out = new(string)
		**out = **in
	}
	if in.ClusterVersion != nil {
		in, out := &in.ClusterVersion, &out.ClusterVersion
		*out = new(string)
		**out = **in
	}
	if in.ContainerNetworkCidr != nil {
		in, out := &in.ContainerNetworkCidr, &out.ContainerNetworkCidr
		*out = new(string)
		**out = **in
	}
	if in.ContainerNetworkType != nil {
		in, out := &in.ContainerNetworkType, &out.ContainerNetworkType
		*out = new(string)
		**out = **in
	}
	if in.DeleteAllNetwork != nil {
		in, out := &in.DeleteAllNetwork, &out.DeleteAllNetwork
		*out = new(string)
		**out = **in
	}
	if in.DeleteAllStorage != nil {
		in, out := &in.DeleteAllStorage, &out.DeleteAllStorage
		*out = new(string)
		**out = **in
	}
	if in.DeleteEFS != nil {
		in, out := &in.DeleteEFS, &out.DeleteEFS
		*out = new(string)
		**out = **in
	}
	if in.DeleteEni != nil {
		in, out := &in.DeleteEni, &out.DeleteEni
		*out = new(string)
		**out = **in
	}
	if in.DeleteEvs != nil {
		in, out := &in.DeleteEvs, &out.DeleteEvs
		*out = new(string)
		**out = **in
	}
	if in.DeleteNet != nil {
		in, out := &in.DeleteNet, &out.DeleteNet
		*out = new(string)
		**out = **in
	}
	if in.DeleteObs != nil {
		in, out := &in.DeleteObs, &out.DeleteObs
		*out = new(string)
		**out = **in
	}
	if in.DeleteSfs != nil {
		in, out := &in.DeleteSfs, &out.DeleteSfs
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.EIP != nil {
		in, out := &in.EIP, &out.EIP
		*out = new(string)
		**out = **in
	}
	if in.EnableVolumeEncryption != nil {
		in, out := &in.EnableVolumeEncryption, &out.EnableVolumeEncryption
		*out = new(bool)
		**out = **in
	}
	if in.EniSubnetCidr != nil {
		in, out := &in.EniSubnetCidr, &out.EniSubnetCidr
		*out = new(string)
		**out = **in
	}
	if in.EniSubnetID != nil {
		in, out := &in.EniSubnetID, &out.EniSubnetID
		*out = new(string)
		**out = **in
	}
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.External != nil {
		in, out := &in.External, &out.External
		*out = new(string)
		**out = **in
	}
	if in.ExternalOtc != nil {
		in, out := &in.ExternalOtc, &out.ExternalOtc
		*out = new(string)
		**out = **in
	}
	if in.FlavorID != nil {
		in, out := &in.FlavorID, &out.FlavorID
		*out = new(string)
		**out = **in
	}
	if in.HighwaySubnetID != nil {
		in, out := &in.HighwaySubnetID, &out.HighwaySubnetID
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IgnoreAddons != nil {
		in, out := &in.IgnoreAddons, &out.IgnoreAddons
		*out = new(bool)
		**out = **in
	}
	if in.IgnoreCertificateClustersData != nil {
		in, out := &in.IgnoreCertificateClustersData, &out.IgnoreCertificateClustersData
		*out = new(bool)
		**out = **in
	}
	if in.IgnoreCertificateUsersData != nil {
		in, out := &in.IgnoreCertificateUsersData, &out.IgnoreCertificateUsersData
		*out = new(bool)
		**out = **in
	}
	if in.InstalledAddons != nil {
		in, out := &in.InstalledAddons, &out.InstalledAddons
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Internal != nil {
		in, out := &in.Internal, &out.Internal
		*out = new(string)
		**out = **in
	}
	if in.KubeProxyMode != nil {
		in, out := &in.KubeProxyMode, &out.KubeProxyMode
		*out = new(string)
		**out = **in
	}
	if in.KubernetesSvcIPRange != nil {
		in, out := &in.KubernetesSvcIPRange, &out.KubernetesSvcIPRange
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MultiAz != nil {
		in, out := &in.MultiAz, &out.MultiAz
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NoAddons != nil {
		in, out := &in.NoAddons, &out.NoAddons
		*out = new(bool)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.SecurityGroupControl != nil {
		in, out := &in.SecurityGroupControl, &out.SecurityGroupControl
		*out = new(string)
		**out = **in
	}
	if in.SecurityGroupNode != nil {
		in, out := &in.SecurityGroupNode, &out.SecurityGroupNode
		*out = new(string)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.SubnetID != nil {
		in, out := &in.SubnetID, &out.SubnetID
		*out = new(string)
		**out = **in
	}
	if in.VPCID != nil {
		in, out := &in.VPCID, &out.VPCID
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterV3Observation.
func (in *ClusterV3Observation) DeepCopy() *ClusterV3Observation {
	if in == nil {
		return nil
	}
	out := new(ClusterV3Observation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterV3Parameters) DeepCopyInto(out *ClusterV3Parameters) {
	*out = *in
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.AuthenticatingProxy != nil {
		in, out := &in.AuthenticatingProxy, &out.AuthenticatingProxy
		*out = make([]AuthenticatingProxyParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.AuthenticatingProxyCA != nil {
		in, out := &in.AuthenticatingProxyCA, &out.AuthenticatingProxyCA
		*out = new(string)
		**out = **in
	}
	if in.AuthenticationMode != nil {
		in, out := &in.AuthenticationMode, &out.AuthenticationMode
		*out = new(string)
		**out = **in
	}
	if in.BillingMode != nil {
		in, out := &in.BillingMode, &out.BillingMode
		*out = new(float64)
		**out = **in
	}
	if in.ClusterType != nil {
		in, out := &in.ClusterType, &out.ClusterType
		*out = new(string)
		**out = **in
	}
	if in.ClusterVersion != nil {
		in, out := &in.ClusterVersion, &out.ClusterVersion
		*out = new(string)
		**out = **in
	}
	if in.ContainerNetworkCidr != nil {
		in, out := &in.ContainerNetworkCidr, &out.ContainerNetworkCidr
		*out = new(string)
		**out = **in
	}
	if in.ContainerNetworkType != nil {
		in, out := &in.ContainerNetworkType, &out.ContainerNetworkType
		*out = new(string)
		**out = **in
	}
	if in.DeleteAllNetwork != nil {
		in, out := &in.DeleteAllNetwork, &out.DeleteAllNetwork
		*out = new(string)
		**out = **in
	}
	if in.DeleteAllStorage != nil {
		in, out := &in.DeleteAllStorage, &out.DeleteAllStorage
		*out = new(string)
		**out = **in
	}
	if in.DeleteEFS != nil {
		in, out := &in.DeleteEFS, &out.DeleteEFS
		*out = new(string)
		**out = **in
	}
	if in.DeleteEni != nil {
		in, out := &in.DeleteEni, &out.DeleteEni
		*out = new(string)
		**out = **in
	}
	if in.DeleteEvs != nil {
		in, out := &in.DeleteEvs, &out.DeleteEvs
		*out = new(string)
		**out = **in
	}
	if in.DeleteNet != nil {
		in, out := &in.DeleteNet, &out.DeleteNet
		*out = new(string)
		**out = **in
	}
	if in.DeleteObs != nil {
		in, out := &in.DeleteObs, &out.DeleteObs
		*out = new(string)
		**out = **in
	}
	if in.DeleteSfs != nil {
		in, out := &in.DeleteSfs, &out.DeleteSfs
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.EIP != nil {
		in, out := &in.EIP, &out.EIP
		*out = new(string)
		**out = **in
	}
	if in.EnableVolumeEncryption != nil {
		in, out := &in.EnableVolumeEncryption, &out.EnableVolumeEncryption
		*out = new(bool)
		**out = **in
	}
	if in.EniSubnetCidr != nil {
		in, out := &in.EniSubnetCidr, &out.EniSubnetCidr
		*out = new(string)
		**out = **in
	}
	if in.EniSubnetID != nil {
		in, out := &in.EniSubnetID, &out.EniSubnetID
		*out = new(string)
		**out = **in
	}
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.FlavorID != nil {
		in, out := &in.FlavorID, &out.FlavorID
		*out = new(string)
		**out = **in
	}
	if in.HighwaySubnetID != nil {
		in, out := &in.HighwaySubnetID, &out.HighwaySubnetID
		*out = new(string)
		**out = **in
	}
	if in.IgnoreAddons != nil {
		in, out := &in.IgnoreAddons, &out.IgnoreAddons
		*out = new(bool)
		**out = **in
	}
	if in.IgnoreCertificateClustersData != nil {
		in, out := &in.IgnoreCertificateClustersData, &out.IgnoreCertificateClustersData
		*out = new(bool)
		**out = **in
	}
	if in.IgnoreCertificateUsersData != nil {
		in, out := &in.IgnoreCertificateUsersData, &out.IgnoreCertificateUsersData
		*out = new(bool)
		**out = **in
	}
	if in.KubeProxyMode != nil {
		in, out := &in.KubeProxyMode, &out.KubeProxyMode
		*out = new(string)
		**out = **in
	}
	if in.KubernetesSvcIPRange != nil {
		in, out := &in.KubernetesSvcIPRange, &out.KubernetesSvcIPRange
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MultiAz != nil {
		in, out := &in.MultiAz, &out.MultiAz
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NoAddons != nil {
		in, out := &in.NoAddons, &out.NoAddons
		*out = new(bool)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.SubnetID != nil {
		in, out := &in.SubnetID, &out.SubnetID
		*out = new(string)
		**out = **in
	}
	if in.VPCID != nil {
		in, out := &in.VPCID, &out.VPCID
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterV3Parameters.
func (in *ClusterV3Parameters) DeepCopy() *ClusterV3Parameters {
	if in == nil {
		return nil
	}
	out := new(ClusterV3Parameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterV3Spec) DeepCopyInto(out *ClusterV3Spec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterV3Spec.
func (in *ClusterV3Spec) DeepCopy() *ClusterV3Spec {
	if in == nil {
		return nil
	}
	out := new(ClusterV3Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterV3Status) DeepCopyInto(out *ClusterV3Status) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterV3Status.
func (in *ClusterV3Status) DeepCopy() *ClusterV3Status {
	if in == nil {
		return nil
	}
	out := new(ClusterV3Status)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DataVolumesInitParameters) DeepCopyInto(out *DataVolumesInitParameters) {
	*out = *in
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = new(string)
		**out = **in
	}
	if in.ExtendParams != nil {
		in, out := &in.ExtendParams, &out.ExtendParams
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KMSID != nil {
		in, out := &in.KMSID, &out.KMSID
		*out = new(string)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Volumetype != nil {
		in, out := &in.Volumetype, &out.Volumetype
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DataVolumesInitParameters.
func (in *DataVolumesInitParameters) DeepCopy() *DataVolumesInitParameters {
	if in == nil {
		return nil
	}
	out := new(DataVolumesInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DataVolumesObservation) DeepCopyInto(out *DataVolumesObservation) {
	*out = *in
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = new(string)
		**out = **in
	}
	if in.ExtendParams != nil {
		in, out := &in.ExtendParams, &out.ExtendParams
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KMSID != nil {
		in, out := &in.KMSID, &out.KMSID
		*out = new(string)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Volumetype != nil {
		in, out := &in.Volumetype, &out.Volumetype
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DataVolumesObservation.
func (in *DataVolumesObservation) DeepCopy() *DataVolumesObservation {
	if in == nil {
		return nil
	}
	out := new(DataVolumesObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DataVolumesParameters) DeepCopyInto(out *DataVolumesParameters) {
	*out = *in
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = new(string)
		**out = **in
	}
	if in.ExtendParams != nil {
		in, out := &in.ExtendParams, &out.ExtendParams
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KMSID != nil {
		in, out := &in.KMSID, &out.KMSID
		*out = new(string)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Volumetype != nil {
		in, out := &in.Volumetype, &out.Volumetype
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DataVolumesParameters.
func (in *DataVolumesParameters) DeepCopy() *DataVolumesParameters {
	if in == nil {
		return nil
	}
	out := new(DataVolumesParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodePoolV3) DeepCopyInto(out *NodePoolV3) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodePoolV3.
func (in *NodePoolV3) DeepCopy() *NodePoolV3 {
	if in == nil {
		return nil
	}
	out := new(NodePoolV3)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodePoolV3) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodePoolV3InitParameters) DeepCopyInto(out *NodePoolV3InitParameters) {
	*out = *in
	if in.AgencyName != nil {
		in, out := &in.AgencyName, &out.AgencyName
		*out = new(string)
		**out = **in
	}
	if in.AvailabilityZone != nil {
		in, out := &in.AvailabilityZone, &out.AvailabilityZone
		*out = new(string)
		**out = **in
	}
	if in.ClusterID != nil {
		in, out := &in.ClusterID, &out.ClusterID
		*out = new(string)
		**out = **in
	}
	if in.DataVolumes != nil {
		in, out := &in.DataVolumes, &out.DataVolumes
		*out = make([]DataVolumesInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DockerBaseSize != nil {
		in, out := &in.DockerBaseSize, &out.DockerBaseSize
		*out = new(float64)
		**out = **in
	}
	if in.DockerLvmConfigOverride != nil {
		in, out := &in.DockerLvmConfigOverride, &out.DockerLvmConfigOverride
		*out = new(string)
		**out = **in
	}
	if in.Flavor != nil {
		in, out := &in.Flavor, &out.Flavor
		*out = new(string)
		**out = **in
	}
	if in.InitialNodeCount != nil {
		in, out := &in.InitialNodeCount, &out.InitialNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.K8STags != nil {
		in, out := &in.K8STags, &out.K8STags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KeyPair != nil {
		in, out := &in.KeyPair, &out.KeyPair
		*out = new(string)
		**out = **in
	}
	if in.MaxNodeCount != nil {
		in, out := &in.MaxNodeCount, &out.MaxNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.MaxPods != nil {
		in, out := &in.MaxPods, &out.MaxPods
		*out = new(float64)
		**out = **in
	}
	if in.MinNodeCount != nil {
		in, out := &in.MinNodeCount, &out.MinNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Os != nil {
		in, out := &in.Os, &out.Os
		*out = new(string)
		**out = **in
	}
	if in.Postinstall != nil {
		in, out := &in.Postinstall, &out.Postinstall
		*out = new(string)
		**out = **in
	}
	if in.Preinstall != nil {
		in, out := &in.Preinstall, &out.Preinstall
		*out = new(string)
		**out = **in
	}
	if in.Priority != nil {
		in, out := &in.Priority, &out.Priority
		*out = new(float64)
		**out = **in
	}
	if in.RootVolume != nil {
		in, out := &in.RootVolume, &out.RootVolume
		*out = make([]RootVolumeInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Runtime != nil {
		in, out := &in.Runtime, &out.Runtime
		*out = new(string)
		**out = **in
	}
	if in.ScaleDownCooldownTime != nil {
		in, out := &in.ScaleDownCooldownTime, &out.ScaleDownCooldownTime
		*out = new(float64)
		**out = **in
	}
	if in.ScaleEnable != nil {
		in, out := &in.ScaleEnable, &out.ScaleEnable
		*out = new(bool)
		**out = **in
	}
	if in.ServerGroupReference != nil {
		in, out := &in.ServerGroupReference, &out.ServerGroupReference
		*out = new(string)
		**out = **in
	}
	if in.Storage != nil {
		in, out := &in.Storage, &out.Storage
		*out = new(string)
		**out = **in
	}
	if in.SubnetID != nil {
		in, out := &in.SubnetID, &out.SubnetID
		*out = new(string)
		**out = **in
	}
	if in.Taints != nil {
		in, out := &in.Taints, &out.Taints
		*out = make([]TaintsInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.UserTags != nil {
		in, out := &in.UserTags, &out.UserTags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodePoolV3InitParameters.
func (in *NodePoolV3InitParameters) DeepCopy() *NodePoolV3InitParameters {
	if in == nil {
		return nil
	}
	out := new(NodePoolV3InitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodePoolV3List) DeepCopyInto(out *NodePoolV3List) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]NodePoolV3, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodePoolV3List.
func (in *NodePoolV3List) DeepCopy() *NodePoolV3List {
	if in == nil {
		return nil
	}
	out := new(NodePoolV3List)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodePoolV3List) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodePoolV3Observation) DeepCopyInto(out *NodePoolV3Observation) {
	*out = *in
	if in.AgencyName != nil {
		in, out := &in.AgencyName, &out.AgencyName
		*out = new(string)
		**out = **in
	}
	if in.AvailabilityZone != nil {
		in, out := &in.AvailabilityZone, &out.AvailabilityZone
		*out = new(string)
		**out = **in
	}
	if in.ClusterID != nil {
		in, out := &in.ClusterID, &out.ClusterID
		*out = new(string)
		**out = **in
	}
	if in.DataVolumes != nil {
		in, out := &in.DataVolumes, &out.DataVolumes
		*out = make([]DataVolumesObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DockerBaseSize != nil {
		in, out := &in.DockerBaseSize, &out.DockerBaseSize
		*out = new(float64)
		**out = **in
	}
	if in.DockerLvmConfigOverride != nil {
		in, out := &in.DockerLvmConfigOverride, &out.DockerLvmConfigOverride
		*out = new(string)
		**out = **in
	}
	if in.Flavor != nil {
		in, out := &in.Flavor, &out.Flavor
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InitialNodeCount != nil {
		in, out := &in.InitialNodeCount, &out.InitialNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.K8STags != nil {
		in, out := &in.K8STags, &out.K8STags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KeyPair != nil {
		in, out := &in.KeyPair, &out.KeyPair
		*out = new(string)
		**out = **in
	}
	if in.MaxNodeCount != nil {
		in, out := &in.MaxNodeCount, &out.MaxNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.MaxPods != nil {
		in, out := &in.MaxPods, &out.MaxPods
		*out = new(float64)
		**out = **in
	}
	if in.MinNodeCount != nil {
		in, out := &in.MinNodeCount, &out.MinNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Os != nil {
		in, out := &in.Os, &out.Os
		*out = new(string)
		**out = **in
	}
	if in.Postinstall != nil {
		in, out := &in.Postinstall, &out.Postinstall
		*out = new(string)
		**out = **in
	}
	if in.Preinstall != nil {
		in, out := &in.Preinstall, &out.Preinstall
		*out = new(string)
		**out = **in
	}
	if in.Priority != nil {
		in, out := &in.Priority, &out.Priority
		*out = new(float64)
		**out = **in
	}
	if in.RootVolume != nil {
		in, out := &in.RootVolume, &out.RootVolume
		*out = make([]RootVolumeObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Runtime != nil {
		in, out := &in.Runtime, &out.Runtime
		*out = new(string)
		**out = **in
	}
	if in.ScaleDownCooldownTime != nil {
		in, out := &in.ScaleDownCooldownTime, &out.ScaleDownCooldownTime
		*out = new(float64)
		**out = **in
	}
	if in.ScaleEnable != nil {
		in, out := &in.ScaleEnable, &out.ScaleEnable
		*out = new(bool)
		**out = **in
	}
	if in.ServerGroupReference != nil {
		in, out := &in.ServerGroupReference, &out.ServerGroupReference
		*out = new(string)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.Storage != nil {
		in, out := &in.Storage, &out.Storage
		*out = new(string)
		**out = **in
	}
	if in.SubnetID != nil {
		in, out := &in.SubnetID, &out.SubnetID
		*out = new(string)
		**out = **in
	}
	if in.Taints != nil {
		in, out := &in.Taints, &out.Taints
		*out = make([]TaintsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.UserTags != nil {
		in, out := &in.UserTags, &out.UserTags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodePoolV3Observation.
func (in *NodePoolV3Observation) DeepCopy() *NodePoolV3Observation {
	if in == nil {
		return nil
	}
	out := new(NodePoolV3Observation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodePoolV3Parameters) DeepCopyInto(out *NodePoolV3Parameters) {
	*out = *in
	if in.AgencyName != nil {
		in, out := &in.AgencyName, &out.AgencyName
		*out = new(string)
		**out = **in
	}
	if in.AvailabilityZone != nil {
		in, out := &in.AvailabilityZone, &out.AvailabilityZone
		*out = new(string)
		**out = **in
	}
	if in.ClusterID != nil {
		in, out := &in.ClusterID, &out.ClusterID
		*out = new(string)
		**out = **in
	}
	if in.DataVolumes != nil {
		in, out := &in.DataVolumes, &out.DataVolumes
		*out = make([]DataVolumesParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DockerBaseSize != nil {
		in, out := &in.DockerBaseSize, &out.DockerBaseSize
		*out = new(float64)
		**out = **in
	}
	if in.DockerLvmConfigOverride != nil {
		in, out := &in.DockerLvmConfigOverride, &out.DockerLvmConfigOverride
		*out = new(string)
		**out = **in
	}
	if in.Flavor != nil {
		in, out := &in.Flavor, &out.Flavor
		*out = new(string)
		**out = **in
	}
	if in.InitialNodeCount != nil {
		in, out := &in.InitialNodeCount, &out.InitialNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.K8STags != nil {
		in, out := &in.K8STags, &out.K8STags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KeyPair != nil {
		in, out := &in.KeyPair, &out.KeyPair
		*out = new(string)
		**out = **in
	}
	if in.MaxNodeCount != nil {
		in, out := &in.MaxNodeCount, &out.MaxNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.MaxPods != nil {
		in, out := &in.MaxPods, &out.MaxPods
		*out = new(float64)
		**out = **in
	}
	if in.MinNodeCount != nil {
		in, out := &in.MinNodeCount, &out.MinNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Os != nil {
		in, out := &in.Os, &out.Os
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Postinstall != nil {
		in, out := &in.Postinstall, &out.Postinstall
		*out = new(string)
		**out = **in
	}
	if in.Preinstall != nil {
		in, out := &in.Preinstall, &out.Preinstall
		*out = new(string)
		**out = **in
	}
	if in.Priority != nil {
		in, out := &in.Priority, &out.Priority
		*out = new(float64)
		**out = **in
	}
	if in.RootVolume != nil {
		in, out := &in.RootVolume, &out.RootVolume
		*out = make([]RootVolumeParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Runtime != nil {
		in, out := &in.Runtime, &out.Runtime
		*out = new(string)
		**out = **in
	}
	if in.ScaleDownCooldownTime != nil {
		in, out := &in.ScaleDownCooldownTime, &out.ScaleDownCooldownTime
		*out = new(float64)
		**out = **in
	}
	if in.ScaleEnable != nil {
		in, out := &in.ScaleEnable, &out.ScaleEnable
		*out = new(bool)
		**out = **in
	}
	if in.ServerGroupReference != nil {
		in, out := &in.ServerGroupReference, &out.ServerGroupReference
		*out = new(string)
		**out = **in
	}
	if in.Storage != nil {
		in, out := &in.Storage, &out.Storage
		*out = new(string)
		**out = **in
	}
	if in.SubnetID != nil {
		in, out := &in.SubnetID, &out.SubnetID
		*out = new(string)
		**out = **in
	}
	if in.Taints != nil {
		in, out := &in.Taints, &out.Taints
		*out = make([]TaintsParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.UserTags != nil {
		in, out := &in.UserTags, &out.UserTags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodePoolV3Parameters.
func (in *NodePoolV3Parameters) DeepCopy() *NodePoolV3Parameters {
	if in == nil {
		return nil
	}
	out := new(NodePoolV3Parameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodePoolV3Spec) DeepCopyInto(out *NodePoolV3Spec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodePoolV3Spec.
func (in *NodePoolV3Spec) DeepCopy() *NodePoolV3Spec {
	if in == nil {
		return nil
	}
	out := new(NodePoolV3Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodePoolV3Status) DeepCopyInto(out *NodePoolV3Status) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodePoolV3Status.
func (in *NodePoolV3Status) DeepCopy() *NodePoolV3Status {
	if in == nil {
		return nil
	}
	out := new(NodePoolV3Status)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3) DeepCopyInto(out *NodeV3) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3.
func (in *NodeV3) DeepCopy() *NodeV3 {
	if in == nil {
		return nil
	}
	out := new(NodeV3)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodeV3) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3DataVolumesInitParameters) DeepCopyInto(out *NodeV3DataVolumesInitParameters) {
	*out = *in
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = new(string)
		**out = **in
	}
	if in.ExtendParams != nil {
		in, out := &in.ExtendParams, &out.ExtendParams
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KMSID != nil {
		in, out := &in.KMSID, &out.KMSID
		*out = new(string)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Volumetype != nil {
		in, out := &in.Volumetype, &out.Volumetype
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3DataVolumesInitParameters.
func (in *NodeV3DataVolumesInitParameters) DeepCopy() *NodeV3DataVolumesInitParameters {
	if in == nil {
		return nil
	}
	out := new(NodeV3DataVolumesInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3DataVolumesObservation) DeepCopyInto(out *NodeV3DataVolumesObservation) {
	*out = *in
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = new(string)
		**out = **in
	}
	if in.ExtendParams != nil {
		in, out := &in.ExtendParams, &out.ExtendParams
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KMSID != nil {
		in, out := &in.KMSID, &out.KMSID
		*out = new(string)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Volumetype != nil {
		in, out := &in.Volumetype, &out.Volumetype
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3DataVolumesObservation.
func (in *NodeV3DataVolumesObservation) DeepCopy() *NodeV3DataVolumesObservation {
	if in == nil {
		return nil
	}
	out := new(NodeV3DataVolumesObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3DataVolumesParameters) DeepCopyInto(out *NodeV3DataVolumesParameters) {
	*out = *in
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = new(string)
		**out = **in
	}
	if in.ExtendParams != nil {
		in, out := &in.ExtendParams, &out.ExtendParams
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KMSID != nil {
		in, out := &in.KMSID, &out.KMSID
		*out = new(string)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Volumetype != nil {
		in, out := &in.Volumetype, &out.Volumetype
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3DataVolumesParameters.
func (in *NodeV3DataVolumesParameters) DeepCopy() *NodeV3DataVolumesParameters {
	if in == nil {
		return nil
	}
	out := new(NodeV3DataVolumesParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3InitParameters) DeepCopyInto(out *NodeV3InitParameters) {
	*out = *in
	if in.AgencyName != nil {
		in, out := &in.AgencyName, &out.AgencyName
		*out = new(string)
		**out = **in
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.AvailabilityZone != nil {
		in, out := &in.AvailabilityZone, &out.AvailabilityZone
		*out = new(string)
		**out = **in
	}
	if in.BandwidthChargeMode != nil {
		in, out := &in.BandwidthChargeMode, &out.BandwidthChargeMode
		*out = new(string)
		**out = **in
	}
	if in.BandwidthSize != nil {
		in, out := &in.BandwidthSize, &out.BandwidthSize
		*out = new(float64)
		**out = **in
	}
	if in.BillingMode != nil {
		in, out := &in.BillingMode, &out.BillingMode
		*out = new(float64)
		**out = **in
	}
	if in.ClusterID != nil {
		in, out := &in.ClusterID, &out.ClusterID
		*out = new(string)
		**out = **in
	}
	if in.DataVolumes != nil {
		in, out := &in.DataVolumes, &out.DataVolumes
		*out = make([]NodeV3DataVolumesInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DockerBaseSize != nil {
		in, out := &in.DockerBaseSize, &out.DockerBaseSize
		*out = new(float64)
		**out = **in
	}
	if in.DockerLvmConfigOverride != nil {
		in, out := &in.DockerLvmConfigOverride, &out.DockerLvmConfigOverride
		*out = new(string)
		**out = **in
	}
	if in.EIPCount != nil {
		in, out := &in.EIPCount, &out.EIPCount
		*out = new(float64)
		**out = **in
	}
	if in.EIPIds != nil {
		in, out := &in.EIPIds, &out.EIPIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.EcsPerformanceType != nil {
		in, out := &in.EcsPerformanceType, &out.EcsPerformanceType
		*out = new(string)
		**out = **in
	}
	if in.ExtendParamChargingMode != nil {
		in, out := &in.ExtendParamChargingMode, &out.ExtendParamChargingMode
		*out = new(float64)
		**out = **in
	}
	if in.FlavorID != nil {
		in, out := &in.FlavorID, &out.FlavorID
		*out = new(string)
		**out = **in
	}
	if in.Iptype != nil {
		in, out := &in.Iptype, &out.Iptype
		*out = new(string)
		**out = **in
	}
	if in.K8STags != nil {
		in, out := &in.K8STags, &out.K8STags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KeyPair != nil {
		in, out := &in.KeyPair, &out.KeyPair
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxPods != nil {
		in, out := &in.MaxPods, &out.MaxPods
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.OrderID != nil {
		in, out := &in.OrderID, &out.OrderID
		*out = new(string)
		**out = **in
	}
	if in.Os != nil {
		in, out := &in.Os, &out.Os
		*out = new(string)
		**out = **in
	}
	if in.Postinstall != nil {
		in, out := &in.Postinstall, &out.Postinstall
		*out = new(string)
		**out = **in
	}
	if in.Preinstall != nil {
		in, out := &in.Preinstall, &out.Preinstall
		*out = new(string)
		**out = **in
	}
	if in.PrivateIP != nil {
		in, out := &in.PrivateIP, &out.PrivateIP
		*out = new(string)
		**out = **in
	}
	if in.ProductID != nil {
		in, out := &in.ProductID, &out.ProductID
		*out = new(string)
		**out = **in
	}
	if in.PublicKey != nil {
		in, out := &in.PublicKey, &out.PublicKey
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.RootVolume != nil {
		in, out := &in.RootVolume, &out.RootVolume
		*out = make([]NodeV3RootVolumeInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Runtime != nil {
		in, out := &in.Runtime, &out.Runtime
		*out = new(string)
		**out = **in
	}
	if in.Sharetype != nil {
		in, out := &in.Sharetype, &out.Sharetype
		*out = new(string)
		**out = **in
	}
	if in.SubnetID != nil {
		in, out := &in.SubnetID, &out.SubnetID
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Taints != nil {
		in, out := &in.Taints, &out.Taints
		*out = make([]NodeV3TaintsInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3InitParameters.
func (in *NodeV3InitParameters) DeepCopy() *NodeV3InitParameters {
	if in == nil {
		return nil
	}
	out := new(NodeV3InitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3List) DeepCopyInto(out *NodeV3List) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]NodeV3, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3List.
func (in *NodeV3List) DeepCopy() *NodeV3List {
	if in == nil {
		return nil
	}
	out := new(NodeV3List)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodeV3List) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3Observation) DeepCopyInto(out *NodeV3Observation) {
	*out = *in
	if in.AgencyName != nil {
		in, out := &in.AgencyName, &out.AgencyName
		*out = new(string)
		**out = **in
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.AvailabilityZone != nil {
		in, out := &in.AvailabilityZone, &out.AvailabilityZone
		*out = new(string)
		**out = **in
	}
	if in.BandwidthChargeMode != nil {
		in, out := &in.BandwidthChargeMode, &out.BandwidthChargeMode
		*out = new(string)
		**out = **in
	}
	if in.BandwidthSize != nil {
		in, out := &in.BandwidthSize, &out.BandwidthSize
		*out = new(float64)
		**out = **in
	}
	if in.BillingMode != nil {
		in, out := &in.BillingMode, &out.BillingMode
		*out = new(float64)
		**out = **in
	}
	if in.ClusterID != nil {
		in, out := &in.ClusterID, &out.ClusterID
		*out = new(string)
		**out = **in
	}
	if in.DataVolumes != nil {
		in, out := &in.DataVolumes, &out.DataVolumes
		*out = make([]NodeV3DataVolumesObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DockerBaseSize != nil {
		in, out := &in.DockerBaseSize, &out.DockerBaseSize
		*out = new(float64)
		**out = **in
	}
	if in.DockerLvmConfigOverride != nil {
		in, out := &in.DockerLvmConfigOverride, &out.DockerLvmConfigOverride
		*out = new(string)
		**out = **in
	}
	if in.EIPCount != nil {
		in, out := &in.EIPCount, &out.EIPCount
		*out = new(float64)
		**out = **in
	}
	if in.EIPIds != nil {
		in, out := &in.EIPIds, &out.EIPIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.EcsPerformanceType != nil {
		in, out := &in.EcsPerformanceType, &out.EcsPerformanceType
		*out = new(string)
		**out = **in
	}
	if in.ExtendParamChargingMode != nil {
		in, out := &in.ExtendParamChargingMode, &out.ExtendParamChargingMode
		*out = new(float64)
		**out = **in
	}
	if in.FlavorID != nil {
		in, out := &in.FlavorID, &out.FlavorID
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Iptype != nil {
		in, out := &in.Iptype, &out.Iptype
		*out = new(string)
		**out = **in
	}
	if in.K8STags != nil {
		in, out := &in.K8STags, &out.K8STags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KeyPair != nil {
		in, out := &in.KeyPair, &out.KeyPair
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxPods != nil {
		in, out := &in.MaxPods, &out.MaxPods
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.OrderID != nil {
		in, out := &in.OrderID, &out.OrderID
		*out = new(string)
		**out = **in
	}
	if in.Os != nil {
		in, out := &in.Os, &out.Os
		*out = new(string)
		**out = **in
	}
	if in.Postinstall != nil {
		in, out := &in.Postinstall, &out.Postinstall
		*out = new(string)
		**out = **in
	}
	if in.Preinstall != nil {
		in, out := &in.Preinstall, &out.Preinstall
		*out = new(string)
		**out = **in
	}
	if in.PrivateIP != nil {
		in, out := &in.PrivateIP, &out.PrivateIP
		*out = new(string)
		**out = **in
	}
	if in.ProductID != nil {
		in, out := &in.ProductID, &out.ProductID
		*out = new(string)
		**out = **in
	}
	if in.PublicIP != nil {
		in, out := &in.PublicIP, &out.PublicIP
		*out = new(string)
		**out = **in
	}
	if in.PublicKey != nil {
		in, out := &in.PublicKey, &out.PublicKey
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.RootVolume != nil {
		in, out := &in.RootVolume, &out.RootVolume
		*out = make([]NodeV3RootVolumeObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Runtime != nil {
		in, out := &in.Runtime, &out.Runtime
		*out = new(string)
		**out = **in
	}
	if in.ServerID != nil {
		in, out := &in.ServerID, &out.ServerID
		*out = new(string)
		**out = **in
	}
	if in.Sharetype != nil {
		in, out := &in.Sharetype, &out.Sharetype
		*out = new(string)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.SubnetID != nil {
		in, out := &in.SubnetID, &out.SubnetID
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Taints != nil {
		in, out := &in.Taints, &out.Taints
		*out = make([]NodeV3TaintsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3Observation.
func (in *NodeV3Observation) DeepCopy() *NodeV3Observation {
	if in == nil {
		return nil
	}
	out := new(NodeV3Observation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3Parameters) DeepCopyInto(out *NodeV3Parameters) {
	*out = *in
	if in.AgencyName != nil {
		in, out := &in.AgencyName, &out.AgencyName
		*out = new(string)
		**out = **in
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.AvailabilityZone != nil {
		in, out := &in.AvailabilityZone, &out.AvailabilityZone
		*out = new(string)
		**out = **in
	}
	if in.BandwidthChargeMode != nil {
		in, out := &in.BandwidthChargeMode, &out.BandwidthChargeMode
		*out = new(string)
		**out = **in
	}
	if in.BandwidthSize != nil {
		in, out := &in.BandwidthSize, &out.BandwidthSize
		*out = new(float64)
		**out = **in
	}
	if in.BillingMode != nil {
		in, out := &in.BillingMode, &out.BillingMode
		*out = new(float64)
		**out = **in
	}
	if in.ClusterID != nil {
		in, out := &in.ClusterID, &out.ClusterID
		*out = new(string)
		**out = **in
	}
	if in.DataVolumes != nil {
		in, out := &in.DataVolumes, &out.DataVolumes
		*out = make([]NodeV3DataVolumesParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DockerBaseSize != nil {
		in, out := &in.DockerBaseSize, &out.DockerBaseSize
		*out = new(float64)
		**out = **in
	}
	if in.DockerLvmConfigOverride != nil {
		in, out := &in.DockerLvmConfigOverride, &out.DockerLvmConfigOverride
		*out = new(string)
		**out = **in
	}
	if in.EIPCount != nil {
		in, out := &in.EIPCount, &out.EIPCount
		*out = new(float64)
		**out = **in
	}
	if in.EIPIds != nil {
		in, out := &in.EIPIds, &out.EIPIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.EcsPerformanceType != nil {
		in, out := &in.EcsPerformanceType, &out.EcsPerformanceType
		*out = new(string)
		**out = **in
	}
	if in.ExtendParamChargingMode != nil {
		in, out := &in.ExtendParamChargingMode, &out.ExtendParamChargingMode
		*out = new(float64)
		**out = **in
	}
	if in.FlavorID != nil {
		in, out := &in.FlavorID, &out.FlavorID
		*out = new(string)
		**out = **in
	}
	if in.Iptype != nil {
		in, out := &in.Iptype, &out.Iptype
		*out = new(string)
		**out = **in
	}
	if in.K8STags != nil {
		in, out := &in.K8STags, &out.K8STags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KeyPair != nil {
		in, out := &in.KeyPair, &out.KeyPair
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxPods != nil {
		in, out := &in.MaxPods, &out.MaxPods
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.OrderID != nil {
		in, out := &in.OrderID, &out.OrderID
		*out = new(string)
		**out = **in
	}
	if in.Os != nil {
		in, out := &in.Os, &out.Os
		*out = new(string)
		**out = **in
	}
	if in.Postinstall != nil {
		in, out := &in.Postinstall, &out.Postinstall
		*out = new(string)
		**out = **in
	}
	if in.Preinstall != nil {
		in, out := &in.Preinstall, &out.Preinstall
		*out = new(string)
		**out = **in
	}
	if in.PrivateIP != nil {
		in, out := &in.PrivateIP, &out.PrivateIP
		*out = new(string)
		**out = **in
	}
	if in.ProductID != nil {
		in, out := &in.ProductID, &out.ProductID
		*out = new(string)
		**out = **in
	}
	if in.PublicKey != nil {
		in, out := &in.PublicKey, &out.PublicKey
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.RootVolume != nil {
		in, out := &in.RootVolume, &out.RootVolume
		*out = make([]NodeV3RootVolumeParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Runtime != nil {
		in, out := &in.Runtime, &out.Runtime
		*out = new(string)
		**out = **in
	}
	if in.Sharetype != nil {
		in, out := &in.Sharetype, &out.Sharetype
		*out = new(string)
		**out = **in
	}
	if in.SubnetID != nil {
		in, out := &in.SubnetID, &out.SubnetID
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Taints != nil {
		in, out := &in.Taints, &out.Taints
		*out = make([]NodeV3TaintsParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3Parameters.
func (in *NodeV3Parameters) DeepCopy() *NodeV3Parameters {
	if in == nil {
		return nil
	}
	out := new(NodeV3Parameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3RootVolumeInitParameters) DeepCopyInto(out *NodeV3RootVolumeInitParameters) {
	*out = *in
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = new(string)
		**out = **in
	}
	if in.ExtendParams != nil {
		in, out := &in.ExtendParams, &out.ExtendParams
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KMSID != nil {
		in, out := &in.KMSID, &out.KMSID
		*out = new(string)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Volumetype != nil {
		in, out := &in.Volumetype, &out.Volumetype
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3RootVolumeInitParameters.
func (in *NodeV3RootVolumeInitParameters) DeepCopy() *NodeV3RootVolumeInitParameters {
	if in == nil {
		return nil
	}
	out := new(NodeV3RootVolumeInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3RootVolumeObservation) DeepCopyInto(out *NodeV3RootVolumeObservation) {
	*out = *in
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = new(string)
		**out = **in
	}
	if in.ExtendParams != nil {
		in, out := &in.ExtendParams, &out.ExtendParams
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KMSID != nil {
		in, out := &in.KMSID, &out.KMSID
		*out = new(string)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Volumetype != nil {
		in, out := &in.Volumetype, &out.Volumetype
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3RootVolumeObservation.
func (in *NodeV3RootVolumeObservation) DeepCopy() *NodeV3RootVolumeObservation {
	if in == nil {
		return nil
	}
	out := new(NodeV3RootVolumeObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3RootVolumeParameters) DeepCopyInto(out *NodeV3RootVolumeParameters) {
	*out = *in
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = new(string)
		**out = **in
	}
	if in.ExtendParams != nil {
		in, out := &in.ExtendParams, &out.ExtendParams
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KMSID != nil {
		in, out := &in.KMSID, &out.KMSID
		*out = new(string)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Volumetype != nil {
		in, out := &in.Volumetype, &out.Volumetype
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3RootVolumeParameters.
func (in *NodeV3RootVolumeParameters) DeepCopy() *NodeV3RootVolumeParameters {
	if in == nil {
		return nil
	}
	out := new(NodeV3RootVolumeParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3Spec) DeepCopyInto(out *NodeV3Spec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3Spec.
func (in *NodeV3Spec) DeepCopy() *NodeV3Spec {
	if in == nil {
		return nil
	}
	out := new(NodeV3Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3Status) DeepCopyInto(out *NodeV3Status) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3Status.
func (in *NodeV3Status) DeepCopy() *NodeV3Status {
	if in == nil {
		return nil
	}
	out := new(NodeV3Status)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3TaintsInitParameters) DeepCopyInto(out *NodeV3TaintsInitParameters) {
	*out = *in
	if in.Effect != nil {
		in, out := &in.Effect, &out.Effect
		*out = new(string)
		**out = **in
	}
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3TaintsInitParameters.
func (in *NodeV3TaintsInitParameters) DeepCopy() *NodeV3TaintsInitParameters {
	if in == nil {
		return nil
	}
	out := new(NodeV3TaintsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3TaintsObservation) DeepCopyInto(out *NodeV3TaintsObservation) {
	*out = *in
	if in.Effect != nil {
		in, out := &in.Effect, &out.Effect
		*out = new(string)
		**out = **in
	}
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3TaintsObservation.
func (in *NodeV3TaintsObservation) DeepCopy() *NodeV3TaintsObservation {
	if in == nil {
		return nil
	}
	out := new(NodeV3TaintsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeV3TaintsParameters) DeepCopyInto(out *NodeV3TaintsParameters) {
	*out = *in
	if in.Effect != nil {
		in, out := &in.Effect, &out.Effect
		*out = new(string)
		**out = **in
	}
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeV3TaintsParameters.
func (in *NodeV3TaintsParameters) DeepCopy() *NodeV3TaintsParameters {
	if in == nil {
		return nil
	}
	out := new(NodeV3TaintsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RootVolumeInitParameters) DeepCopyInto(out *RootVolumeInitParameters) {
	*out = *in
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = new(string)
		**out = **in
	}
	if in.ExtendParams != nil {
		in, out := &in.ExtendParams, &out.ExtendParams
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KMSID != nil {
		in, out := &in.KMSID, &out.KMSID
		*out = new(string)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Volumetype != nil {
		in, out := &in.Volumetype, &out.Volumetype
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RootVolumeInitParameters.
func (in *RootVolumeInitParameters) DeepCopy() *RootVolumeInitParameters {
	if in == nil {
		return nil
	}
	out := new(RootVolumeInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RootVolumeObservation) DeepCopyInto(out *RootVolumeObservation) {
	*out = *in
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = new(string)
		**out = **in
	}
	if in.ExtendParams != nil {
		in, out := &in.ExtendParams, &out.ExtendParams
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KMSID != nil {
		in, out := &in.KMSID, &out.KMSID
		*out = new(string)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Volumetype != nil {
		in, out := &in.Volumetype, &out.Volumetype
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RootVolumeObservation.
func (in *RootVolumeObservation) DeepCopy() *RootVolumeObservation {
	if in == nil {
		return nil
	}
	out := new(RootVolumeObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RootVolumeParameters) DeepCopyInto(out *RootVolumeParameters) {
	*out = *in
	if in.ExtendParam != nil {
		in, out := &in.ExtendParam, &out.ExtendParam
		*out = new(string)
		**out = **in
	}
	if in.ExtendParams != nil {
		in, out := &in.ExtendParams, &out.ExtendParams
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.KMSID != nil {
		in, out := &in.KMSID, &out.KMSID
		*out = new(string)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.Volumetype != nil {
		in, out := &in.Volumetype, &out.Volumetype
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RootVolumeParameters.
func (in *RootVolumeParameters) DeepCopy() *RootVolumeParameters {
	if in == nil {
		return nil
	}
	out := new(RootVolumeParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TaintsInitParameters) DeepCopyInto(out *TaintsInitParameters) {
	*out = *in
	if in.Effect != nil {
		in, out := &in.Effect, &out.Effect
		*out = new(string)
		**out = **in
	}
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TaintsInitParameters.
func (in *TaintsInitParameters) DeepCopy() *TaintsInitParameters {
	if in == nil {
		return nil
	}
	out := new(TaintsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TaintsObservation) DeepCopyInto(out *TaintsObservation) {
	*out = *in
	if in.Effect != nil {
		in, out := &in.Effect, &out.Effect
		*out = new(string)
		**out = **in
	}
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TaintsObservation.
func (in *TaintsObservation) DeepCopy() *TaintsObservation {
	if in == nil {
		return nil
	}
	out := new(TaintsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TaintsParameters) DeepCopyInto(out *TaintsParameters) {
	*out = *in
	if in.Effect != nil {
		in, out := &in.Effect, &out.Effect
		*out = new(string)
		**out = **in
	}
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TaintsParameters.
func (in *TaintsParameters) DeepCopy() *TaintsParameters {
	if in == nil {
		return nil
	}
	out := new(TaintsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ValuesInitParameters) DeepCopyInto(out *ValuesInitParameters) {
	*out = *in
	if in.Basic != nil {
		in, out := &in.Basic, &out.Basic
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Custom != nil {
		in, out := &in.Custom, &out.Custom
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Flavor != nil {
		in, out := &in.Flavor, &out.Flavor
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ValuesInitParameters.
func (in *ValuesInitParameters) DeepCopy() *ValuesInitParameters {
	if in == nil {
		return nil
	}
	out := new(ValuesInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ValuesObservation) DeepCopyInto(out *ValuesObservation) {
	*out = *in
	if in.Basic != nil {
		in, out := &in.Basic, &out.Basic
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Custom != nil {
		in, out := &in.Custom, &out.Custom
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Flavor != nil {
		in, out := &in.Flavor, &out.Flavor
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ValuesObservation.
func (in *ValuesObservation) DeepCopy() *ValuesObservation {
	if in == nil {
		return nil
	}
	out := new(ValuesObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ValuesParameters) DeepCopyInto(out *ValuesParameters) {
	*out = *in
	if in.Basic != nil {
		in, out := &in.Basic, &out.Basic
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Custom != nil {
		in, out := &in.Custom, &out.Custom
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Flavor != nil {
		in, out := &in.Flavor, &out.Flavor
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ValuesParameters.
func (in *ValuesParameters) DeepCopy() *ValuesParameters {
	if in == nil {
		return nil
	}
	out := new(ValuesParameters)
	in.DeepCopyInto(out)
	return out
}
